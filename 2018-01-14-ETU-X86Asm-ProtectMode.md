
前面一篇总结了X86汇编中实模式的阅读笔记，这一篇总结一下保护模式的阅读笔记。

#### 32位X86处理器 ####

在32位处理器上，8个通用寄存器扩展为32位，段寄存器CS/SS/DS/ES扩展出描述符高速缓冲器，用于缓存保护模式下的短描述符（当然32位处理器的段寄存器 高速缓存在实模式下也是有用的，用其中的20位保存段寄存器的基地址），并且32位处理器上还多出FS/GS两个段寄存器。

32位处理器上启用了保护模式后，根据分段机制计算出来的地址值，即线性地址，这个地址在没有开启分页机制情况下就是要访问的物理地址。

32位处理器也有更灵活的内存寻址方式，除了ESP无法当作内存操作中的变址寄存器外，其他的都可以使用。如下图，在16位处理器中，只有BX/BP/SI/DI可以作为变址寻址；而在32位的处理器中，所有的通用寄存器都可以作为变址寻址的寄存器。

![图1 16位处理器内存寻址方式](2018-01-14-ETU-X86Asm-ProtectMode-16bit-mem-address.jpg)

![图2 32位处理器内存寻址方式](2018-01-14-ETU-X86Asm-ProtectMode-32bit-mem-address.jpg)

#### GDT描述符格式 ####

系统中包含了GDT和LDT两个描述符表，差别不大，这里以GDT表的项为例介绍一下。如下图给出了GDT表项的格式。

![图3 存储器短描述符格式](2018-01-14-ETU-X86Asm-ProtectMode-Descriptor-Formats.jpg)

整个描述符为64位，即8个字节。其中的三块段基地址组合起来形成32位的数据，记录了该项所描述的段的基地址；两块段界限组合起来形成20位的值，它是所描述段的段界限（这个只是界限值，还有单位）；除了这两大块，还有多个属性值，依次如下所述。

**G**: Granularity，即粒度。它其实就是段界限的单位值，如果为0，段界限则是以字节为单位；如果为1，段界限以4K字节为单位。

**D/B**: 默认操作数大小/默认栈指针大小，或者上部边界标志。对于代码段，该位为D位，用于指定默认偏移地址和操作数大小（D=1表示32位代码/D=0表示16位代码）；对于栈段，该位为B位，进行隐式栈操作时，使用SP还是ESP寄存器（B=0则使用SP，B=1使用ESP）。

**L**: 64位代码段标志，保留给64位处理器使用，32位处理器设置为0即可。

**AVL**: 保留位，留给用户程序使用。

**P**:: Segment Present，段存在位，表示段是否存在内存中（可能被换出到磁盘上）。

**DPL**: 描述符的特权级别（Descriptor Privilege Level，DPL），两位可以表示0～3的4个级别。

**S**: 用于描述描述符类型，该位为0，表示是系统段（即调用门，陷阱门等）；该位为1，表示是代码段或数据段。

**TYPE**: 对于数据段和代码段的解释不通，数据段四位分别是X-E-W-A，而代码段则分别是X-C-R-A。其中X表示是否可执行，E表示数据段的扩展方向，C表示代码段是否为一致性代码，W为数据段读写标志位，W=1可写，R为代码段可读标志位，A为是否访问过。

#### 进入保护模式过程 ####

**GDT设置并加载**: GDT表的第一个描述符（索引0）必须为空描述符，或NULL描述符。其后的描述符则依据上一节的说明进行设置。而加载GDTR寄存器，则需要使用lgdt指令，即偏移值在高地址。

```
	gdt_size dw 0x1F
	gdt_base dd 0x00007c00
	...
	...

	lgdt gdt_size
```

**A20地址线**：在8086之后的CPU中为了兼容16位的运行模式，增加了一个第21根地址线（即A20）的开关，这样可以兼容老的软件运行。在书中代码保护模式下都是32位代码（16位保护模式不再多说），所以要开启A20地址线，开启A20地址线的方法很多，这里使用Fast A20开启，如下代码。

```
	in al, 0x92
    or al, 0x2
    out 0x92, al
```



#### NASM汇编 ####

在NASM中使用`bits 16`标识编译为16位代码，`bits 32`标识指示编译为32位代码。

#### 汇编指令 ####

**lgdt**: sgdt，lgdt是将操作数指向的gdt内容加载到GDTR中，而sgdt是将GDTR中的数据导出到内存中。




By Andy @2018-01-12 11:20:38
