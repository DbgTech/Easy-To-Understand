
前面一篇总结了X86汇编中实模式的阅读笔记，这一篇总结一下保护模式的阅读笔记。

#### 32位X86处理器 ####

在32位处理器上，8个通用寄存器扩展为32位，段寄存器CS/SS/DS/ES扩展出描述符高速缓冲器，用于缓存保护模式下的短描述符（当然32位处理器的段寄存器 高速缓存在实模式下也是有用的，用其中的20位保存段寄存器的基地址），并且32位处理器上还多出FS/GS两个段寄存器。

32位处理器上启用了保护模式后，根据分段机制计算出来的地址值，即线性地址，这个地址在没有开启分页机制情况下就是要访问的物理地址。

32位处理器也有更灵活的内存寻址方式，除了ESP无法当作内存操作中的变址寄存器外，其他的都可以使用。如下图，在16位处理器中，只有BX/BP/SI/DI可以作为变址寻址；而在32位的处理器中，所有的通用寄存器都可以作为变址寻址的寄存器。

![图1 16位处理器内存寻址方式](2018-01-14-ETU-X86Asm-ProtectMode-16bit-mem-address.jpg)

![图2 32位处理器内存寻址方式](2018-01-14-ETU-X86Asm-ProtectMode-32bit-mem-address.jpg)

#### GDT描述符格式 ####

在保护模式中首先会碰到的概念就是GDT，CPU的保护模式概念中包含了GDT和LDT两个描述符表，差别不大，这里以GDT表的项为例介绍一下。如下图给出了GDT表项的格式。

![图3 存储器短描述符格式](2018-01-14-ETU-X86Asm-ProtectMode-Descriptor-Formats.jpg)

整个描述符为64位，即8个字节。其中的三块段基地址组合起来形成32位的数据，记录了该项所描述的段的基地址；两块段界限组合起来形成20位的值，它是所描述段的段界限（这个只是界限值，还有单位）；除了这两大块，还有多个属性值，依次如下所述。

**G**: Granularity，即粒度。它其实就是段界限的单位值，如果为0，段界限则是以字节为单位；如果为1，段界限以4K字节为单位。

**D/B**: 默认操作数大小/默认栈指针大小，或者上部边界标志。对于代码段，该位为D位，用于指定默认偏移地址和操作数大小（D=1表示32位代码/D=0表示16位代码）；对于栈段，该位为B位，进行隐式栈操作时，使用SP还是ESP寄存器（B=0则使用SP，B=1使用ESP）。

**L**: 64位代码段标志，保留给64位处理器使用，32位处理器设置为0即可。

**AVL**: 保留位，留给用户程序使用。

**P**:: Segment Present，段存在位，表示段是否存在内存中（可能被换出到磁盘上）。

**DPL**: 描述符的特权级别（Descriptor Privilege Level，DPL），两位可以表示0～3的4个级别。

**S**: 用于描述描述符类型，该位为0，表示是系统段（即调用门，陷阱门等）；该位为1，表示是代码段或数据段。

**TYPE**: 对于数据段和代码段的解释不通，数据段四位分别是X-E-W-A，而代码段则分别是X-C-R-A。其中X表示是否可执行，E表示数据段的扩展方向，C表示代码段是否为一致性代码，W为数据段读写标志位，W=1可写，R为代码段可读标志位，A为是否访问过。

#### 进入保护模式过程 ####

**GDT设置并加载**: GDT表的第一个描述符（索引0）必须为空描述符，或NULL描述符。其后的描述符则依据上一节的说明进行设置。而加载GDTR寄存器，则需要使用lgdt指令，即偏移值在高地址。

```
	gdt_size dw 0x1F
	gdt_base dd 0x00007c00
	...
	...

	lgdt gdt_size
```

**A20地址线**：在8086之后的CPU中为了兼容16位的运行模式，增加了一个第21根地址线（即A20）的开关，这样可以兼容老的软件运行。在书中代码保护模式下都是32位代码（16位保护模式不再多说），所以要开启A20地址线，开启A20地址线的方法很多，这里使用Fast A20开启，如下代码。

```
	in al, 0x92
    or al, 0x2
    out 0x92, al
```

IBM兼容机将A20地址线放到了键盘控制器内，端口号为0x60，向端口写入数据就可以控制A20地址线的开关，这种方式比较繁琐，从网上找了一段代码，如下。

```
act20addr:
    call wait_8042free ;;等待8042为空
    mov al,0x0D1       ;;D1的意思是向8042端口的P2写数据
    mov dx,0x064
    out dx,al
    call wait_8042free
    mov al,0x0DF   ;;DF为11011111，写入P2，根据图示，A20位置1，开通了A20地址线
    mov dx,0x060
    out dx,al
    ret

wait_8042free:
 .ll_begin:
    in al,0x64
    test al,0x02  ;;测试指令，与运算。判断第二位是否为0，如果为0，则代表8042是空的
    jnz .ll_begin ;;如果运算为0，即8042为空，则返回，不为空，则继续读取缓冲器内容
    ret
```

**控制寄存器**：开启保护模式下一个步骤就是设置控制寄存器。控制寄存器也是一组，有很多个，这里只需要CR0寄存器，CR0寄存器的第一位（位0）是保护模式允许位（Protection Enable，PE）。开启保护模式只需要将CR0的位0置位为1。

```
	mov eax, cr0
	or cr0, 0x1
	mov cr0, eax
```

开启了保护模式后，段寄存器的使用就与实模式不同了，实模式下仅仅使用段寄存器隐藏部分的低20位作为寻址的基地址；保护模式下，整个64位的隐藏部分都利用起来，它缓存了段寄存器所索引的GDT表中项的内容。如下图4所示为一个段选择子的示意图。最低两位为RPL；位2为TI标记，它标记了描述符索引从GDT中还是从LDT中进行索引，TI=0表示要索引GDT；描述符索引用于标识GDT/LDT中的描述符（Index*8）。

![图4 段寄存器内容获取方式](2018-01-14-ETU-X86Asm-ProtectMode-Selector.jpg)

图5给出了使用段寄存器内容获取描述符的示意图。使用13位的Index乘上8加上GDTR中的基地址，就得到GDT中描述符的地址，然后将选择的描述符内容取到段寄存器的隐藏部分，以加快访问。

![图5 段寄存器内容获取方式](2018-01-14-ETU-X86Asm-ProtectMode-Seg-Selector-Gontent.jpg)

**进入32位代码**：进入32位保护模式的最后一步就是进入32位代码中继续执行。通过修改CR0的值CPU进入了保护模式，但是目前CPU的所有寄存器还保持在16位实模式下的内容，所以要进行更新；另外，当前的CPU都具有流水线，多条指令已经存在于流水线上了，现在要进入到32位保护模式代码，则要将已经按照16位实模式译码的指令清空掉。要做到这两点，只需要一个远跳转，一方面更新代码的段寄存器CS，另一方面修改指令指针寄存器位EIP。

```
jmp dword 0x0008:flush
```

flash其实就是jmp指令后的一个标号，目的就是要更新CS:EIP。这里这条指令仅仅更新了CS:EIP，其他的段寄存器还是需要在使用之前进行更新的，否则会出现错误。这里的dword还是必要的，现在CPU也支持16位保护模式，而我们这里要直接跳转成32位保护模式，所以用DWORD标记，直接跳转为32位代码。

#### 关于栈段 ####

普通的数据段是向上扩展的，这个比较好理解，就是段描述符中的段基地址就是最小的地址，而而最大地址即段基地址加上段限制。比如十一章中给出的数据段的描述符，可知其基地址为0x000b8000，所以最小可以访问的地址即0x0008B000；段限制为0x0FFFF，同时段粒度为字节，那么最大可访问地址即0x000B8000+0x0FFFF=0x000C7FFF。

```
mov dword [bx + 4*4], 0x8000FFFF
mov dword [bx + 4*5], 0x0040920b
```

与数据段向上扩展相同的栈段，它的上下限计算方法类似，可参考上述的计算方法。而对于栈段向下扩展而言，那么计算方法就完全不同了，段限制给出的是栈可访问的最小地址，而非最大地址。如11章的栈段的描述符所示。

```
mov dword [bx + 4*6], 0x00007a00
mov dword [bx + 4*7], 0x00409600
```

段基地址为0x00000000，段界限为0x07A00，段粒度为1，那么这里对于ESP来说只要满足`ESP < 段界限 * 段粒度`即可，即栈段的范围为`0x00007A00~0xFFFFFFFF`。其实在代码中将ESP设置为了0x7C00，所以栈的实际大小为512字节。但是不可否认的是ESP取上述范围内大于0x7C00的值也完全是合法的，这显然超出了最初指向设置一个512字节栈段的初衷。

#### 段机制下的程序加载与运行 ####

**引导程序**


**内核程序**


**用户程序**


#### 控制寄存器 ####

**CR0**:

CR0的各个位的示意图如下所示：

![图6 CR0](2018-01-14-ETU-X86Asm-ProtectMode-CR0.jpg)

PE：位0，保护模式允许位（Protection Enable，PE），该位置1，处理器进入保护模式。

**CR2**:

**CR3**:

**CR4**:



#### NASM汇编 ####

在NASM中使用`bits 16`标识编译为16位代码，`bits 32`标识指示编译为32位代码。

#### 汇编指令 ####

**lgdt**: sgdt，lgdt是将操作数指向的gdt内容加载到GDTR中，而sgdt是将GDTR中的数据导出到内存中。

**xchg**: 交换两个操作数的内容，操作数可以是8/16/32位。

```
xchg al, ah
xchg ax, bx
xchg eax, ebx
```

**bswap**: 交换字节，即将寄存器按照镜像形式进行四个字节对换。

**cpuid**: 用于返回处理器的标识和特性信息

**cmovcc**: 

**movzx**: movsx

**cmpsb**: cmpsb（cmpsw, cmpsd）比较字节，DS:ESI指定源字符串，ES:EDI指定目的字符串，EFLAGS的DF指定增长方向，DF=0表示正向比较。cmps指令只比较一次，要使用rep*进行多次比较，ECX保存比较的次数。rep前缀就是反复重复，对于这种需要检查对比结果的情况无法起作用，则需要使用repe（repz）或repne（repnz）来实现当比较相等或不等时结束。

**xlat**: 


#### Bochs调试 ####

**info gdt**：查看GDT表所有内容，info gdt 2，查看索引为2的GDT表项内容。相同的还有info ldt

**sreg**: 查看段寄存器的内容，还有creg查看控制寄存器的内容，CR0,CR1等

> 注: 保护模式下一直在强调保护，即代码段为只读，不可以修改；只读数据段也只允许读取而不允许修改。这些只是针对当前的代码段或只读数据段，如果将一个可读可写的段指向和代码段相同的内存，使用这个可读可写的数据段就可以修改代码段对应的任何位置的数据。这也是12章中作者说的alias段的要讲述内容，并且用冒泡排序修正了代码段的一串字符的序列。

By Andy @2018-01-12 11:20:38
