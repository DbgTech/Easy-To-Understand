
前面一篇总结了X86汇编中实模式的阅读笔记，这一篇总结一下保护模式的阅读笔记。

#### 32位X86处理器 ####

在32位处理器上，8个通用寄存器扩展为32位，段寄存器CS/SS/DS/ES扩展出描述符高速缓冲器，用于缓存保护模式下的短描述符（当然32位处理器的段寄存器 高速缓存在实模式下也是有用的，用其中的20位保存段寄存器的基地址），并且32位处理器上还多出FS/GS两个段寄存器。

32位处理器上启用了保护模式后，根据分段机制计算出来的地址值，即线性地址，这个地址在没有开启分页机制情况下就是要访问的物理地址。

32位处理器也有更灵活的内存寻址方式，除了ESP无法当作内存操作中的变址寄存器外，其他的都可以使用。如下图，在16位处理器中，只有BX/BP/SI/DI可以作为变址寻址；而在32位的处理器中，所有的通用寄存器都可以作为变址寻址的寄存器。

![图1 16位处理器内存寻址方式](2018-01-14-ETU-X86Asm-ProtectMode-16bit-mem-address.jpg)

![图2 32位处理器内存寻址方式](2018-01-14-ETU-X86Asm-ProtectMode-32bit-mem-address.jpg)

#### GDT描述符格式 ####

系统中包含了GDT和LDT两个描述符表，差别不大，这里以GDT表的项为例介绍一下。如下图给出了GDT表项的格式。

![图3 存储器短描述符格式](2018-01-14-ETU-X86Asm-ProtectMode-Descriptor-Formats.jpg)

整个描述符为64位，即8个字节。其中的三块段基地址组合起来形成32位的数据，记录了该项所描述的段的基地址；两块段界限组合起来形成20位的值，它是所描述段的段界限（这个只是界限值，还有单位）；除了这两大块，还有多个属性值，依次如下所述。

**G**: Granularity，即粒度。它其实就是段界限的单位值，如果为0，段界限则是以字节为单位；如果为1，段界限以4K字节为单位。

**D/B**: 默认操作数大小/默认栈指针大小，或者上部边界标志。对于代码段，该位为D位，用于指定默认偏移地址和操作数大小（D=1表示32位代码/D=0表示16位代码）；对于栈段，该位为B位，进行隐式栈操作时，使用SP还是ESP寄存器（B=0则使用SP，B=1使用ESP）。

**L**: 64位代码段标志，保留给64位处理器使用，32位处理器设置为0即可。

**AVL**: 保留位，留给用户程序使用。

**P**:: Segment Present，段存在位，表示段是否存在内存中（可能被换出到磁盘上）。

**DPL**: 描述符的特权级别（Descriptor Privilege Level，DPL），两位可以表示0～3的4个级别。

**S**: 用于描述描述符类型，该位为0，表示是系统段（即调用门，陷阱门等）；该位为1，表示是代码段或数据段。

**TYPE**: 对于数据段和代码段的解释不通，数据段四位分别是X-E-W-A，而代码段则分别是X-C-R-A。其中X表示是否可执行，E表示数据段的扩展方向，C表示代码段是否为一致性代码，W为数据段读写标志位，W=1可写，R为代码段可读标志位，A为是否访问过。

#### 进入保护模式过程 ####

**GDT设置并加载**: GDT表的第一个描述符（索引0）必须为空描述符，或NULL描述符。其后的描述符则依据上一节的说明进行设置。而加载GDTR寄存器，则需要使用lgdt指令，即偏移值在高地址。

```
	gdt_size dw 0x1F
	gdt_base dd 0x00007c00
	...
	...

	lgdt gdt_size
```

**A20地址线**：在8086之后的CPU中为了兼容16位的运行模式，增加了一个第21根地址线（即A20）的开关，这样可以兼容老的软件运行。在书中代码保护模式下都是32位代码（16位保护模式不再多说），所以要开启A20地址线，开启A20地址线的方法很多，这里使用Fast A20开启，如下代码。

```
	in al, 0x92
    or al, 0x2
    out 0x92, al
```

**控制寄存器**：开启保护模式下一个步骤就是设置控制寄存器。控制寄存器也是一组，有很多个，这里只需要CR0寄存器，CR0寄存器的第一位（位0）是保护模式允许位（Protection Enable，PE）。开启保护模式只需要将CR0的位0置位为1。

```
	mov eax, cr0
	or cr0, 0x1
	mov cr0, eax
```

开启了保护模式后，段寄存器的使用就与实模式不同了，实模式下仅仅使用段寄存器隐藏部分的低20位作为寻址的基地址；保护模式下，整个64位的隐藏部分都利用起来，它缓存了段寄存器所索引的GDT表中项的内容。

![图4 段寄存器内容获取方式](2018-01-14-ETU-X86Asm-ProtectMode-Seg-Selector-Gontent.jpg)

**进入32位代码**：进入32位保护模式的最后一步就是进入32位代码中继续执行。通过修改CR0的值CPU进入了保护模式，但是目前CPU的所有寄存器还保持在16位实模式下的内容，所以要进行更新；另外，当前的CPU都具有流水线，多条指令已经存在于流水线上了，现在要进入到32位保护模式代码，则要将已经按照16位实模式译码的指令清空掉。要做到这两点，只需要一个远跳转，一方面更新代码的段寄存器CS，另一方面修改指令指针寄存器位EIP。

```
jmp dword 0x0008:flush
```

flash其实就是jmp指令后的一个标号，目的就是要更新CS:EIP。这里这条指令仅仅更新了CS:EIP，其他的段寄存器还是需要在使用之前进行更新的，否则会出现错误。这里的dword还是必要的，现在CPU也支持16位保护模式，而我们这里要直接跳转成32位保护模式，所以用DWORD标记，直接跳转为32位代码。

#### 关于栈段 ####

普通的数据段是向上扩展的，这个比较好理解，就是段描述符中的段基地址就是最小的地址，而而最大地址即段基地址加上段限制。比如十一章中给出的数据段的描述符，可知其基地址为0x000b8000，所以最小可以访问的地址即0x0008B000；段限制为0x0FFFF，同时段粒度为字节，那么最大可访问地址即0x000B8000+0x0FFFF=0x000C7FFF。

```
mov dword [bx + 4*4], 0x8000FFFF
mov dword [bx + 4*5], 0x0040920b
```

与数据段向上扩展相同的栈段，它的上下限计算方法类似，可参考上述的计算方法。而对于栈段向下扩展而言，那么计算方法就完全不同了，段限制给出的是栈可访问的最小地址，而非最大地址。如11章的栈段的描述符所示。

```
mov dword [bx + 4*6], 0x00007a00
mov dword [bx + 4*7], 0x00409600  
```

段基地址为0x00000000，段界限为0x07A00，段粒度为1，那么这里对于ESP来说只要满足`ESP < 段界限 * 段粒度`即可，即栈段的范围为`0x00007A00~0xFFFFFFFF`。其实在代码中将ESP设置为了0x7C00，所以栈的实际大小为512字节。但是不可否认的是ESP取上述范围内大于0x7C00的值也完全是合法的，这显然超出了最初指向设置一个512字节栈段的初衷。

#### NASM汇编 ####

在NASM中使用`bits 16`标识编译为16位代码，`bits 32`标识指示编译为32位代码。

#### 汇编指令 ####

**lgdt**: sgdt，lgdt是将操作数指向的gdt内容加载到GDTR中，而sgdt是将GDTR中的数据导出到内存中。

**xchg**: 交换两个操作数的内容，操作数可以是8/16/32位。

```
xchg al, ah
xchg ax, bx
xchg eax, ebx
```

#### Bochs调试 ####

**info gdt**：查看GDT表所有内容，info gdt 2，查看索引为2的GDT表项内容。相同的还有info ldt

**sreg**: 查看段寄存器的内容，还有creg查看控制寄存器的内容，CR0,CR1等


By Andy @2018-01-12 11:20:38
